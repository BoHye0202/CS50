✔︎ 샘플미션. 채점 프로그램을 만들어보자!
-미션을 수행하시는데 도움이 될 수 있게 미션샘플을 답지와 함께 제공해드립니다. 미션샘플은 제출용이 아닌 아래의 미션을 풀기위해 참고하기 위한 미션입니다.
 

1. 미션 제목
버블정렬 프로그램 작성

 

 

2. 지시문
0에서 9사이의 숫자 5개를 입력으로 받아 버블정렬을 이용하여 숫자를 오름차순으로 정렬하는 프로그램을 작성해봅시다. 숫자를 입력받는 부분은 따로 구현하지 않고 프로그램 안에서 배열로 선언하는 것으로 가정하고, 숫자에는 중복이 있을 수 있습니다.

예) 
입력값: 32415 -> 출력값: 12345
입력값: 12791 -> 출력값: 11279

 

3. 핵심 개념
#버블정렬

🔔 답안
`
#include <stdio.h>

int main(void) {  
  int number[5] = {1, 2, 7, 9, 1};
  int temp;
  for (int i=0; i < 5; i++)
  {
    for (int j=0; j < 5 - i - 1; j++ )
    {
      if (number[j] > number[j+1])
      {
        temp = number[j];
        number[j] = number[j+1];
        number[j+1] = temp;
      }
    }
  }

  for (int i=0; i < 5; i++)
  {
    printf("%d", number[i]);
  }
  return 0;
}
`

✔︎ 미션 1.


1. 미션 제목
숫자 애너그램 찾기

 

 

2. 지시문
‘애너그램’이란 문자를 재배열하여 다른 뜻을 가진 단어로 바꾸는 것을 말합니다. 예를 들면 영어의 ‘tea’와 ‘eat’과 같이, 각 단어를 구성하는 알파벳의 구성은 같지만 뜻은 다른 두 단어를 말합니다. 우리말에는 ‘문전박대’와 ‘대박전문’과 같은 예를 들 수 있습니다. 우리는 문자 대신 숫자를 이용해서 애너그램을 찾는 프로그램을 만들어봅시다. 5자리의 숫자 1쌍이 입력으로 주어지며 애너그램일 경우에는 “True”를 아닐 경우에는 “False”를 출력하도록 합시다. 숫자를 입력받는 부분은 따로 구현하지 않고 프로그램 내부에 배열로 선언하는 것으로 가정하고, 숫자에는 중복이 있을 수 있습니다.


예)
입력값: 12345, 54321 -> 출력값: True
입력값: 14258, 25431 -> 출력값: False
입력값: 11132, 21131 -> 출력값: True


3. 핵심 개념
#애너그램 #정렬알고리즘

 

 

 

✔︎ 미션 2.


1. 미션 제목
친구들과 최단거리에 있는 집 구하기

 

 

2. 지시문
David의 친구들은 한 거리에 모두 모여살고 있습니다. David은 이번에 친구들이 살고 있는 거리로 이사를 가기로 했는데, 친구들의 집에서 거리가 가장 가까운 집을 구해서 그곳으로 이사를 하고 싶습니다. 모두 같은 거리에 살고 있으므로 아래 그림과 같이 친구들의 집 위치를 수직선 상에 표현할 수 있고, 그 때 집은 항상 정수점 위에만 있다고 가정합니다.

![image](https://user-images.githubusercontent.com/61692777/114854031-5c9e8700-9e1f-11eb-8d86-4165532d1d5d.png)

이 때, David이 어느 위치에 있는 집으로 이사를 가야 모든 친구들의 집까지의 거리의 합이 최소가 될 수 있는지 생각해보고 이를 출력하는 프로그램을 작성해봅시다. 그리고 이 때 이 프로그램의 시간복잡도(Big O)가 얼마나 되는지 얘기해봅시다. 어떻게 하면 시간복잡도를 최소화할 수 있을지도 같이 생각해봅시다. 집이 있을 수 있는 위치는 한자리 정수로만 구성되며, 숫자를 입력받는 부분은 따로 구현하지 않고 프로그램 내부에 배열로 선언하는 것으로 가정하고, 숫자에는 중복이 있을 수 있습니다.

예)
입력값: 12345 -> 출력값: 3
입력값: 2224 -> 출력값: 2
* 2224의 경우 2에 3명이 같이 사는 것으로 보실 수 있지만 문제상 같은 위치에 여러명이 살 수 있다는 가정으로 풀어주세요^^

 


3. 핵심 개념
#거리의합이최소 #중앙값 #평균값

 

시간 복잡도 : 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킵니다.
가장 간단히 중고등학교때 배운 고차함수만을 생각한다면  제일 높은 차수를 가리킨다고 생각하셔도 됩니다.
y=x^3+1의 시간 복잡도는 O(x^3)이 되며 y=x+5의 시간 복잡도는 O(x)가 됩니다.
시간 복잡도는 입력 함수 값의 변화가 결과 시간에 얼마나 큰 폭으로 영향을 미치는 지를 
직관적으로 파악하기 위해 사용합니다.

 

* 본 문제의 경우 문제를 푸는데 도움이 되는 힌트가 있습니다. 알고리즘의 경우 방법을 직접 고민해보고 찾는 것이 중요합니다. 때문에 고민을 하시다가 도저히 풀 수가 없을때 아래의 힌트를 참고해주시길 바랍니다.


-> '         ' 사이를 마우스로 블록을 하면 힌트가 나옵니다.

 '평균값과 중앙값 중에 거리의 합을 최소로 만드는 값은 어떤 것인지 먼저 생각해봅시다.'

 

 

 

✔︎ 미션 3(난이도 상).


1. 미션 제목
최단 시간에 다리건너기

 

 

2. 지시문
N명의 사람들로 구성된 한 그룹이 밤중에 다리를 건너려고 합니다. 한 번에 최대 두 명 까지만 다리를 건널 수 있으며 다리 위를 지나가는 사람들은 반드시 손전등을 가지고 가야 합니다. n명의 사람들한테는 손전등이 한 개밖에 없기 때문에 남아 있는 사람들이 다리를 건너려면 어떤 식으로든 손전등을 가지고 다시 다리를 건너지 않은 사람들이 있는 곳으로 돌아가는 일을 해야합니다. 사람마다 다리를 건너는 속도가 다른데, 그룹의 속도는 가장 느린 구성원의 속도에 따라 결정됩니다. 가장 짧은 시간 안에 n명이 모두 다리를 건널 수 있는 방법과 그 시간을 출력하는 프로그램을 작성해봅시다.


입력으로 첫 줄에는 n이 입력되며 그 다음 줄부터 n개의 줄에 걸쳐서 각 사람들이 다리를 건너는 시간이 입력됩니다. 입력은 100명을 넘기지 않습니다.


출력은 맨 첫 줄에는 n명의 사람들이 모두 다리를 건너는데 걸리는 총 시간을 출력하고, 그 다음줄부터는 그 과정을 출력하면 됩니다. 이 때 각 줄에는 정수가 하나 또는 두 개가 들어가는데, 이 정수는 어떤 사람들이 다리를 건너가는지를 나타냅니다. 각 사람은 그 사람이 건너가는데 걸리는 시간으로 표시하며, 건너가고 오는 순서대로 출력해야 합니다. 최소 시간을 달성하는 방법이 여러가지가 있을 경우 그 중 아무 방법이나 출력해도 괜찮습니다. 완전한 프로그램을 작성하기 어려운 경우에는 pseudo code를 작성해도 좋습니다. 다만 이 경우에는 최대한 자세히 적어야 합니다. 숫자를 입력받는 부분은 따로 구현하지 않고 프로그램 내부에서 따로 선언하는 것으로 가정합니다.


예)
입력값:
4
1
2
5
10


출력값:
17
1 2
1
5 10
2
1 2



3. 핵심 개념
#정렬알고리즘

 

* 본 문제의 경우 문제를 푸는데 도움이 되는 힌트가 있습니다. 알고리즘의 경우 방법을 직접 고민해보고 찾는 것이 중요합니다. 때문에 고민을 하시다가 도저히 풀 수가 없을때 아래의 힌트를 참고해주시길 바랍니다.

 

-> '         ' 사이를 마우스로 블록을 하면 힌트가 나옵니다.

 '각 사람들이 다리를 건너는 시간에 따라서 예)에 있는 출력값과 같은 방법으로 다리를 건너는 것이 최선이 아닌 경우도 있습니다. 어떤 경우에 그렇게 되는지, 그리고 그 때는 어떤 방법으로 다리를 건너는 것이 최선인지 생각해봅시다'



->  아래 두번째 '         ' 사이에는 결정적인 힌트가 있습니다. 왠만하면 참고하지 말고 풀어보시고 힘들면 확인하세요 :)

 

'

다리를 가장 빠르게 건너는 방법은 상황에 따라서 두가지로 나뉘게 됩니다. 이것을 찾아낼 수 있는지가 첫번째 출제 의도입니다. 두가지 방법은 다음과 같습니다

현재 다리를 건너지 않은 사람들 n명이 있을 때, 중에 제일 빠른 사람을 1번, 그 다음 빠른 사람을 2번, 제일 느린 사람을 n번, 그 다음으로 느린 사람을 n-1번이라고 하겠습니다.

첫번째 방법은 다음과 같습니다

1번과 2번이 건너간다 > 1번이 돌아온다 > n-1번과 n번이 건너간다 > 2번이 돌아온다 >(1번과 2번이 건너간다)

총 걸린시간: 2번 + 1번 + n번 + 2번 (+ 2번)

두번째 방법은 다음과 같습니다

1번과 n번이 건너간다 > 1번이 돌아온다 > 1번과 n-1번이 건너간다 > 1번이 돌아온다 > (1번과 2번이 건너간다)

총 걸린시간: n번 + 1번 + n-1번 + 1번 (+ 2번)

 

두 경우를 비교해보면 결국 2번의 소요시간 x 2가 1번 소요시간 + n-1번 소요시간보다 더 크냐 작으냐에 의해서 결정되는 것입니다.

그래서 이 경우를 구분해서 두 개로 경우를 나누어 생각할 수 있는지를 보는 것이 첫번째 출제의도입니다.

 그런데 위 방법에서 괄호로 표시한 부분 이전까지만 수행을 하면, 현재 상태는 n-1번 사람과 n번 사람만 다리를 건너간 상태가 됩니다. n이 4였다면 여기서 괄호 안처럼 1번과 2번이 건너가면 끝나지만, 4보다 큰 경우에는 역시 남아있는 다른 사람들도 건너가야 하기 때문에 다시 맨 처음으로 돌아가서 건너간 2명을 뺀 나머지를 n명이라고 했을 때 똑같이 1번, 2번(둘은 변하지 않음) 그리고 n-1, n번 사람을 놓고 같은 방법으로 두 명을 건너게 하는 방식을 계속 반복하면 그것이 최소 시간에 다리를 건너가는 방법입니다.

 

여기서 또 한가지 추가로 생각해야할 것은 사람의 수가 홀수인 경우에는 마지막에 3명만 남게 되는데, 이 때 빠른 순서대로 1번, 2번, 3번이라고 하면 당연히 이 경우는 1번과 3번이 건너간 뒤에 1번이 다시 돌아오고, 1번 2번이 마지막으로 건너가는 방식이 최소시간입니다. 알고리즘을 작성함에 있어서 이렇게 3명만 남는 경우에 대해서 따로 처리를 해주느냐를 보는 것이 두번째 출제 의도입니다. ' 

 

 

✔︎ 미션 4 (난이도 상).


1. 미션 제목
가장 큰 낙하거리 찾기

 ![image](https://user-images.githubusercontent.com/61692777/114853985-501a2e80-9e1f-11eb-9faf-b111e05655e9.png)


 

2. 지시문
상자들이 쌓여있는 방이 있습니다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙하거리가 가장 큰 상자를 구하여 그 낙하거리를 출력하는 프로그램을 작성해 봅시다. 아래 그림에서 총 26개 상자가 회전 후, 오른쪽 그림과 같은 상태가 됩니다. A상자의 낙하거리가 7로 가장 크므로 7을 출력하면 됩니다. 회전 결과, B 상자의 낙하거리는 6이고, C상자의 낙하거리는 1입니다.



중력은 회전이 완료된 이후에 적용되며, 상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없습니다. 입력으로는 첫 줄에 각 방의 가로 길이 N(2 ≤ N ≤ 100)과 방의 세로 길이 M(2 ≤ N ≤ 100)이 주어지며, 다음 줄에는 N개의 상자들이 쌓여있는 높이 H(0 ≤ H ≤ M)가 주어집니다. 가장 직관적인 방법은 MxN내의 모든 box에 대해서 낙하거리를 계산한 뒤 정렬 알고리즘을 사용하여 최댓값을 찾으면 되는 문제라고 생각할 수 있습니다. 이 방법은 시간 복잡도(Big O)가 얼마나 될 지 먼저 생각해봅시다. 그리고, 이보다 더 효율적인 방법으로 프로그램을 작성해봅시다. 완전한 프로그램을 작성하는 것이 힘들 경우에는 pseudo code로 작성해도 좋습니다. 다만 이 경우에는 최대한 자세히 적어야 합니다. 숫자를 입력받는 부분은 따로 구현하지 않고 프로그램 내부에서 따로 선언하는 것으로 가정합니다.

 

예)
입력값:
9 8 // 방의 가로 길이 N, 세로 길이 M
7 4 2 0 0 6 0 7 0 // 상자들이 쌓여있는 높이
출력값:
7 // 가장 큰 낙하거리

 

3. 핵심 개념
# 최대값찾기

 
